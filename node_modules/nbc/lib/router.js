var url = require('url'),
    _ = require('underscore');

function removeTrailingSlash(path) {
    var len = path.length;
    if((path[len-1] == '/') && (len > 1)) {
        return path.slice(0, -1); 
    }

    return path;
}

function TypeConverter(typeName, regexPattern, converter) {
    this.typeName = typeName;
    this.regexPattern = regexPattern;
    this.converter = converter;
}

var typeConverters = {
    'int': new TypeConverter('int', '(\\-?\\d+?)', function(v) { return parseInt(v); }),
    'float': new TypeConverter('float', '([-+]?[0-9]*\\.?[0-9]+?)', function(v) { return parseFloat(v); }),
    'str': new TypeConverter('str', '([^/]*?)', function(v) { return v; })
};

function Handler(methods, urlRule, callback) {
    if(!_.isArray(methods)) {
        methods = [methods];
    }

    this.methods = methods;
    this.urlRule = removeTrailingSlash(urlRule);
    this.callback = callback;

    this._urlRegex = null;
    this._paramNames = [];
    this._paramTypes = [];

    this.processUrlRule();
}

Handler.prototype.match = function(path) {   
    var m = this._urlRegex.exec(path);
    if(m) {
        return m.slice(1);
    } else {
        return null;
    }
};

Handler.prototype.acceptMethod = function(req) {
    return this.methods.indexOf(req.method) >= 0;
};

Handler.prototype.processUrlRule = function() {
    if(!_.isString(this.urlRule)) {
        throw new Error('expected string urlRule: ' + this.urlRule);
    }

    if(!(/^(?:\/(?:[^<>\s]*)|(?:<\w+(?:\:\w+)?>))+\/?$/.test(this.urlRule))) {
        throw new Error('invalid urlRule: ' + this.urlRule);
    }

    var tokens = this.urlRule.split('/');
    if((tokens.length < 2) || (tokens[0] !== '')) {
        throw new Error('invalid urlRule: ' + this.urlRule);
    }

    // better use String.replace(regexp, function())?
    tokens = _.map(tokens, function(token) {
        var m = /^<(\w+)(:\w+)??>$/.exec(token);
        if(m) {
            var paramName = m[1];
            var paramType = (m[2] || ':str').slice(1);

            var typeConverter = typeConverters[paramType];
            if(!typeConverter) {
                throw new Exception('unknown param type: ' + paramType);
            }

            this._paramNames.push(paramName);
            this._paramTypes.push(paramType);

            return typeConverter.regexPattern;
        }
        return token;
    }, this);   

    this._urlRegex = new RegExp('^' + tokens.join('/') + '$');
};

function Router(options) {
    this.handlers = [];
}

Router.prototype.handle = function(req, res, next) {
    var urlMatchFound = false;
    var handled = false;

    var urlParts = url.parse(req.url);

    var path = removeTrailingSlash(urlParts.pathname);

    for(var i=0, len=this.handlers.length; i<len; ++i) {
        var handler = this.handlers[i];

        var params = handler.match(path);
        if(params) {
            urlMatchFound = true;

            if(handler.acceptMethod(req)) {
                for(var p=0, plen=handler._paramTypes.length; p<plen; ++p) {
                    var paramType = handler._paramTypes[p];
                    var typeConverter = typeConverters[paramType];
                    if(typeConverter) {
                        params[p] = typeConverter.converter.call(typeConverter, params[p]);
                    }
                }

                handler.callback.apply(handler, [req, res].concat(params));

                handled = true;
                break;
            }
        }
    }

    if(!handled) {
        if(urlMatchFound) {
            res.statusCode = 405;
            res.end();
        } else {
            next();
        }
    }
};

Router.prototype.register = function(methods, urlRule, callback) {
    this.handlers.push(new Handler(methods, urlRule, callback));
};

exports = module.exports = Router;